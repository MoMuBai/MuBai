package com.lzw.library.utils;

import android.graphics.Bitmap;
import android.graphics.Bitmap.Config;
import android.graphics.BitmapFactory;
import android.graphics.Canvas;
import android.graphics.LinearGradient;
import android.graphics.Matrix;
import android.graphics.Paint;
import android.graphics.PixelFormat;
import android.graphics.PorterDuff.Mode;
import android.graphics.PorterDuffXfermode;
import android.graphics.Rect;
import android.graphics.RectF;
import android.graphics.Shader.TileMode;
import android.graphics.drawable.BitmapDrawable;
import android.graphics.drawable.Drawable;
import android.media.ThumbnailUtils;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;

/**
 * Created by lzw on 2016/11/8.
 */
public final class ImageUtil {

        /**
         * Transfer drawable to bitmap
         *
         * @param drawable
         * @return
         */
        public static Bitmap drawableToBitmap(Drawable drawable) {
                int w = drawable.getIntrinsicWidth();
                int h = drawable.getIntrinsicHeight();

                Config config = drawable.getOpacity() != PixelFormat.OPAQUE ? Config.ARGB_8888
                          : Config.RGB_565;
                Bitmap bitmap = Bitmap.createBitmap(w, h, config);
                Canvas canvas = new Canvas(bitmap);
                drawable.setBounds(0, 0, w, h);
                drawable.draw(canvas);
                return bitmap;
        }

        /**
         * Bitmap to drawable
         *
         * @param bitmap
         * @return
         */
        public static Drawable bitmapToDrawable(Bitmap bitmap) {
                return new BitmapDrawable(bitmap);
        }

        /**
         * Input stream to bitmap
         *
         * @param inputStream
         * @return
         * @throws Exception
         */
        public static Bitmap inputStreamToBitmap(InputStream inputStream)
                  throws Exception {
                return BitmapFactory.decodeStream(inputStream);
        }

        /**
         * Byte transfer to bitmap
         *
         * @param byteArray
         * @return
         */
        public static Bitmap byteToBitmap(byte[] byteArray) {
                if (byteArray.length != 0) {
                        return BitmapFactory
                                  .decodeByteArray(byteArray, 0, byteArray.length);
                } else {
                        return null;
                }
        }

        /**
         * Byte transfer to drawable
         *
         * @param byteArray
         * @return
         */
        public static Drawable byteToDrawable(byte[] byteArray) {
                ByteArrayInputStream ins = null;
                if (byteArray != null) {
                        ins = new ByteArrayInputStream(byteArray);
                }
                return Drawable.createFromStream(ins, null);
        }

        /**
         * Bitmap transfer to bytes
         *
         * @param byteArray
         * @return
         */
        public static byte[] bitmapToBytes(Bitmap bm) {
                byte[] bytes = null;
                if (bm != null) {
                        ByteArrayOutputStream baos = new ByteArrayOutputStream();
                        bm.compress(Bitmap.CompressFormat.PNG, 100, baos);
                        bytes = baos.toByteArray();
                }
                return bytes;
        }

        /**
         * Drawable transfer to bytes
         *
         * @param drawable
         * @return
         */
        public static byte[] drawableToBytes(Drawable drawable) {
                BitmapDrawable bitmapDrawable = (BitmapDrawable) drawable;
                Bitmap bitmap = bitmapDrawable.getBitmap();
                byte[] bytes = bitmapToBytes(bitmap);
                ;
                return bytes;
        }

        /**
         * Base64 to byte[]
         //	 */
//	public static byte[] base64ToBytes(String base64) throws IOException {
//		byte[] bytes = Base64.decode(base64);
//		return bytes;
//	}
//
//	/**
//	 * Byte[] to base64
//	 */
//	public static String bytesTobase64(byte[] bytes) {
//		String base64 = Base64.encode(bytes);
//		return base64;
//	}

        /**
         * Create reflection images
         *
         * @param bitmap
         * @return
         */
        public static Bitmap createReflectionImageWithOrigin(Bitmap bitmap) {
                final int reflectionGap = 4;
                int w = bitmap.getWidth();
                int h = bitmap.getHeight();

                Matrix matrix = new Matrix();
                matrix.preScale(1, -1);

                Bitmap reflectionImage = Bitmap.createBitmap(bitmap, 0, h / 2, w,
                          h / 2, matrix, false);

                Bitmap bitmapWithReflection = Bitmap.createBitmap(w, (h + h / 2),
                          Config.ARGB_8888);

                Canvas canvas = new Canvas(bitmapWithReflection);
                canvas.drawBitmap(bitmap, 0, 0, null);
                Paint deafalutPaint = new Paint();
                canvas.drawRect(0, h, w, h + reflectionGap, deafalutPaint);

                canvas.drawBitmap(reflectionImage, 0, h + reflectionGap, null);

                Paint paint = new Paint();
                LinearGradient shader = new LinearGradient(0, bitmap.getHeight(), 0,
                          bitmapWithReflection.getHeight() + reflectionGap, 0x70ffffff,
                          0x00ffffff, TileMode.CLAMP);
                paint.setShader(shader);
                // Set the Transfer mode to be porter duff and destination in
                paint.setXfermode(new PorterDuffXfermode(Mode.DST_IN));
                // Draw a rectangle using the paint with our linear gradient
                canvas.drawRect(0, h, w, bitmapWithReflection.getHeight()
                          + reflectionGap, paint);

                return bitmapWithReflection;
        }

        /**
         * Get rounded corner images
         *
         * @param bitmap
         * @param roundPx 5 10
         * @return
         */
        public static Bitmap getRoundedCornerBitmap(Bitmap bitmap, float roundPx) {
                int w = bitmap.getWidth();
                int h = bitmap.getHeight();
                Bitmap output = Bitmap.createBitmap(w, h, Config.ARGB_8888);
                Canvas canvas = new Canvas(output);
                final int color = 0xff424242;
                final Paint paint = new Paint();
                final Rect rect = new Rect(0, 0, w, h);
                final RectF rectF = new RectF(rect);
                paint.setAntiAlias(true);
                canvas.drawARGB(0, 0, 0, 0);
                paint.setColor(color);
                canvas.drawRoundRect(rectF, roundPx, roundPx, paint);
                paint.setXfermode(new PorterDuffXfermode(Mode.SRC_IN));
                canvas.drawBitmap(bitmap, rect, rect, paint);

                return output;
        }

        /**
         * Resize the bitmap
         *
         * @param bitmap
         * @param width
         * @param height
         * @return
         */
        public static Bitmap zoomBitmap(Bitmap bitmap, int width, int height) {
                int w = bitmap.getWidth();
                int h = bitmap.getHeight();
                Matrix matrix = new Matrix();
                float scaleWidth = ((float) width / w);
                float scaleHeight = ((float) height / h);
                matrix.postScale(scaleWidth, scaleHeight);
                Bitmap newbmp = Bitmap.createBitmap(bitmap, 0, 0, w, h, matrix, true);
                return newbmp;
        }

        /**
         * Resize the drawable
         *
         * @param drawable
         * @param w
         * @param h
         * @return
         */
        public static Drawable zoomDrawable(Drawable drawable, int w, int h) {
                int width = drawable.getIntrinsicWidth();
                int height = drawable.getIntrinsicHeight();
                Bitmap oldbmp = drawableToBitmap(drawable);
                Matrix matrix = new Matrix();
                float sx = ((float) w / width);
                float sy = ((float) h / height);
                matrix.postScale(sx, sy);
                Bitmap newbmp = Bitmap.createBitmap(oldbmp, 0, 0, width, height,
                          matrix, true);
                return new BitmapDrawable(newbmp);
        }

        /**
         * Get images from SD card by path and the name of image
         *
         * @param photoName
         * @return
         */
        public static Bitmap getPhotoFromSDCard(String path, String photoName) {
                Bitmap photoBitmap = BitmapFactory.decodeFile(path + "/" + photoName + ".png");
                if (photoBitmap == null) {
                        return null;
                } else {
                        return photoBitmap;
                }
        }

        /**
         * Check the SD card
         *
         * @return
         */
        public static boolean checkSDCardAvailable() {
                return android.os.Environment.getExternalStorageState().equals(android.os.Environment.MEDIA_MOUNTED);
        }

        /**
         * Get image from SD card by path and the name of image
         *
         * @param fileName
         * @return
         */
        public static boolean findPhotoFromSDCard(String path, String photoName) {
                boolean flag = false;

                if (checkSDCardAvailable()) {
                        File dir = new File(path);
                        if (dir.exists()) {
                                File folders = new File(path);
                                File photoFile[] = folders.listFiles();
                                for (int i = 0; i < photoFile.length; i++) {
                                        String fileName = photoFile[i].getName().split("\\.")[0];
                                        if (fileName.equals(photoName)) {
                                                flag = true;
                                        }
                                }
                        } else {
                                flag = false;
                        }
//			File file = new File(path + "/" + photoName  + ".jpg" );
//			if (file.exists()) {
//				flag = true;
//			}else {
//				flag = false;
//			}

                } else {
                        flag = false;
                }
                return flag;
        }

        /**
         * Save image to the SD card
         *
         * @param photoBitmap
         * @param photoName
         * @param path
         */
        public static void savePhotoToSDCard(Bitmap photoBitmap, String path, String photoName) {
                if (checkSDCardAvailable()) {
                        File dir = new File(path);
                        if (!dir.exists()) {
                                dir.mkdirs();
                        }

                        File photoFile = new File(path, photoName + ".png");
                        FileOutputStream fileOutputStream = null;
                        try {
                                fileOutputStream = new FileOutputStream(photoFile);
                                if (photoBitmap != null) {
                                        if (photoBitmap.compress(Bitmap.CompressFormat.PNG, 100, fileOutputStream)) {
                                                fileOutputStream.flush();
//						fileOutputStream.close();
                                        }
                                }
                        } catch (FileNotFoundException e) {
                                photoFile.delete();
                                e.printStackTrace();
                        } catch (IOException e) {
                                photoFile.delete();
                                e.printStackTrace();
                        } finally {
                                try {
                                        fileOutputStream.close();
                                } catch (IOException e) {
                                        e.printStackTrace();
                                }
                        }
                }
        }

        /**
         * Delete the image from SD card
         *
         * @param path file:///sdcard/temp.jpg
         */
        public static void deleteAllPhoto(String path) {
                if (checkSDCardAvailable()) {
                        File folder = new File(path);
                        File[] files = folder.listFiles();
                        for (int i = 0; i < files.length; i++) {
                                files[i].delete();
                        }
                }
        }

        /**
         * Delete the image from SD card by fileName
         *
         * @param path
         * @param fileName
         */
        public static void deletePhotoAtPathAndName(String path, String fileName) {
                if (checkSDCardAvailable()) {
                        File folder = new File(path);
                        File[] files = folder.listFiles();
                        for (int i = 0; i < files.length; i++) {
                                if (files[i].getName().split("\\.")[0].equals(fileName)) {
                                        files[i].delete();
                                }
                        }
                }
        }


        /**
         * 质量压缩方法
         */
        public static Bitmap compressImage(Bitmap image) {

                ByteArrayOutputStream baos = new ByteArrayOutputStream();
                image.compress(Bitmap.CompressFormat.PNG, 100, baos);//质量压缩方法，这里100表示不压缩，把压缩后的数据存放到baos中
                int options = 100;
                while (baos.toByteArray().length / 1024 > 100) {  //循环判断如果压缩后图片是否大于100kb,大于继续压缩
                        baos.reset();//重置baos即清空baos
                        image.compress(Bitmap.CompressFormat.JPEG, options, baos);//这里压缩options%，把压缩后的数据存放到baos中
                        options -= 10;//每次都减少10
                }
                ByteArrayInputStream isBm = new ByteArrayInputStream(baos.toByteArray());//把压缩后的数据baos存放到ByteArrayInputStream中
                Bitmap bitmap = BitmapFactory.decodeStream(isBm, null, null);//把ByteArrayInputStream数据生成图片
                return bitmap;
        }


        /**
         * 图片按比例大小压缩方法（根据路径获取图片并压缩）：
         */
        public static Bitmap getImage(String srcPath) {
                BitmapFactory.Options newOpts = new BitmapFactory.Options();
                //开始读入图片，此时把options.inJustDecodeBounds 设回true了
                newOpts.inJustDecodeBounds = true;
                Bitmap bitmap = BitmapFactory.decodeFile(srcPath, newOpts);//此时返回bm为空

                newOpts.inJustDecodeBounds = false;
                int w = newOpts.outWidth;
                int h = newOpts.outHeight;
                //现在主流手机比较多是1920*1080分辨率，所以高和宽我们设置为
                float hh = 1920f;//这里设置高度为1920f
                float ww = 1080f;//这里设置宽度为1080f
                //缩放比。由于是固定比例缩放，只用高或者宽其中一个数据进行计算即可
                int be = 1;//be=1表示不缩放
                if (w > h && w > ww) {//如果宽度大的话根据宽度固定大小缩放
                        be = (int) (newOpts.outWidth / ww);
                } else if (w < h && h > hh) {//如果高度高的话根据宽度固定大小缩放
                        be = (int) (newOpts.outHeight / hh);
                }
                if (be <= 0)
                        be = 1;
                newOpts.inSampleSize = be;//设置缩放比例
                //重新读入图片，注意此时已经把options.inJustDecodeBounds 设回false了
                bitmap = BitmapFactory.decodeFile(srcPath, newOpts);
                return compressImage(bitmap);//压缩好比例大小后再进行质量压缩
        }


        /**
         * 图片按比例大小压缩方法（根据Bitmap图片压缩)
         */
        public static Bitmap comp(Bitmap image) {

                ByteArrayOutputStream baos = new ByteArrayOutputStream();
                image.compress(Bitmap.CompressFormat.JPEG, 100, baos);
                if (baos.toByteArray().length / 1024 > 1024) {//判断如果图片大于1M,进行压缩避免在生成图片（BitmapFactory.decodeStream）时溢出
                        baos.reset();//重置baos即清空baos
                        image.compress(Bitmap.CompressFormat.JPEG, 50, baos);//这里压缩50%，把压缩后的数据存放到baos中
                }
                ByteArrayInputStream isBm = new ByteArrayInputStream(baos.toByteArray());
                BitmapFactory.Options newOpts = new BitmapFactory.Options();
                //开始读入图片，此时把options.inJustDecodeBounds 设回true了
                newOpts.inJustDecodeBounds = true;
                Bitmap bitmap = BitmapFactory.decodeStream(isBm, null, newOpts);
                newOpts.inJustDecodeBounds = false;
                int w = newOpts.outWidth;
                int h = newOpts.outHeight;
                //现在主流手机比较多是1920*1080分辨率，所以高和宽我们设置为
                float hh = 1920f;//这里设置高度为1920f
                float ww = 1080f;//这里设置宽度为1080f
                //缩放比。由于是固定比例缩放，只用高或者宽其中一个数据进行计算即可
                int be = 1;//be=1表示不缩放
                if (w > h && w > ww) {//如果宽度大的话根据宽度固定大小缩放
                        be = (int) (newOpts.outWidth / ww);
                } else if (w < h && h > hh) {//如果高度高的话根据宽度固定大小缩放
                        be = (int) (newOpts.outHeight / hh);
                }
                if (be <= 0)
                        be = 1;
                newOpts.inSampleSize = be;//设置缩放比例
                //重新读入图片，注意此时已经把options.inJustDecodeBounds 设回false了
                isBm = new ByteArrayInputStream(baos.toByteArray());
                bitmap = BitmapFactory.decodeStream(isBm, null, newOpts);
                return compressImage(bitmap);//压缩好比例大小后再进行质量压缩
        }

        /**
         * 根据指定的图像路径和大小来获取缩略图
         * 此方法有两点好处：
         * 1. 使用较小的内存空间，第一次获取的bitmap实际上为null，只是为了读取宽度和高度，
         * 第二次读取的bitmap是根据比例压缩过的图像，第三次读取的bitmap是所要的缩略图。
         * 2. 缩略图对于原图像来讲没有拉伸，这里使用了2.2版本的新工具ThumbnailUtils，使
         * 用这个工具生成的图像不会被拉伸。
         *
         * @param imagePath 图像的路径
         * @param width     指定输出图像的宽度
         * @param height    指定输出图像的高度
         * @return 生成的缩略图
         */
        public static Bitmap getImageThumbnail(String imagePath, int width, int height) {
                Bitmap bitmap = null;
                BitmapFactory.Options options = new BitmapFactory.Options();
                options.inJustDecodeBounds = true;
                // 获取这个图片的宽和高，注意此处的bitmap为null
                bitmap = BitmapFactory.decodeFile(imagePath, options);
                options.inJustDecodeBounds = false; // 设为 false
                // 计算缩放比
                int h = options.outHeight;
                int w = options.outWidth;
                int beWidth = w / width;
                int beHeight = h / height;
                int be = 1;
                if (beWidth < beHeight) {
                        be = beWidth;
                } else {
                        be = beHeight;
                }
                if (be <= 0) {
                        be = 1;
                }
                options.inSampleSize = be;
                // 重新读入图片，读取缩放后的bitmap，注意这次要把options.inJustDecodeBounds 设为 false
                bitmap = BitmapFactory.decodeFile(imagePath, options);
                // 利用ThumbnailUtils来创建缩略图，这里要指定要缩放哪个Bitmap对象
                bitmap = ThumbnailUtils.extractThumbnail(bitmap, width, height,
                          ThumbnailUtils.OPTIONS_RECYCLE_INPUT);
                return bitmap;
        }

        /**
         * 获取视频的缩略图
         * 先通过ThumbnailUtils来创建一个视频的缩略图，然后再利用ThumbnailUtils来生成指定大小的缩略图。
         * 如果想要的缩略图的宽和高都小于MICRO_KIND，则类型要使用MICRO_KIND作为kind的值，这样会节省内存。
         *
         * @param videoPath 视频的路径
         * @param width     指定输出视频缩略图的宽度
         * @param height    指定输出视频缩略图的高度度
         * @param kind      参照MediaStore.Images.Thumbnails类中的常量MINI_KIND和MICRO_KIND。
         *                  其中，MINI_KIND: 512 x 384，MICRO_KIND: 96 x 96
         * @return 指定大小的视频缩略图
         */
        public static Bitmap getVideoThumbnail(String videoPath, int width, int height,
                                               int kind) {
                Bitmap bitmap = null;
                // 获取视频的缩略图
                bitmap = ThumbnailUtils.createVideoThumbnail(videoPath, kind);
                System.out.println("w" + bitmap.getWidth());
                System.out.println("h" + bitmap.getHeight());
                bitmap = ThumbnailUtils.extractThumbnail(bitmap, width, height,
                          ThumbnailUtils.OPTIONS_RECYCLE_INPUT);
                return bitmap;
        }


}
